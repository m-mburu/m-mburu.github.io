{
  "hash": "8d309404fc632826e4aac79987c16c1d",
  "result": {
    "markdown": "---\ntitle: \"Shap Calculation R\"\nauthor: \"Mburu\"\ndate: \"3/5/2021\"\noutput:\n  html_document:\n    toc: yes\n    toc_depth: 2\n    toc_float:\n      collapsed: no\n      smooth_scroll: no\n    theme: united\n    highlight: pygments\n  html_notebook:\n    toc: yes\n    toc_depth: '2'\n---\n\n\n\n\n## Packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(data.table)\nlibrary(xgboost)\nlibrary(knitr)\nlibrary(broom)\nlibrary(caret)\nlibrary(ggthemes)\nlibrary(DT)\nlibrary(glmnet)\n\ncancer <- fread(\"data.csv\")\n\ncancer[, V33 := NULL]\n```\n:::\n\n\n## Head\n\nA mini example of calculating shap values in R. I used an open source data set from Kaggle. See more about [Wiscosin breast cancer data set](https://www.kaggle.com/uciml/breast-cancer-wisconsin-data). I use [IML package](https://github.com/christophM/iml) from R I prefer it since you can calculate from any model. At this time I have tested it using models from caret package but they have examples from mlr package and h20 packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(cancer)  %>%\n  datatable(options = list(scrollX = TRUE)) \n```\n:::\n\n\n## Scale predictors\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnms <- names(cancer)\nnew_nms <- gsub(\"\\\\s\", \"_\", nms) %>% tolower() %>% str_trim()\nsetnames(cancer, nms, new_nms)\npat_id <- cancer$id\ncancer[, id := NULL]\npredictors <- names(cancer)[3:31]\nscale01 <- function(x){\n  y = (x - min(x))/(max(x) - min(x))\n  return(y)\n}\ncancer[, (predictors) := lapply(.SD, function(x) scale01(x)), .SDcols = predictors ]\ncancer[, diagnosis := factor(diagnosis, levels = c(\"M\", \"B\"))]\n\nhead(cancer)  %>%\n  datatable(options = list(scrollX = TRUE)) \n```\n:::\n\n\n## Boxplots\n\n-   I like this especially when you want to see if there is difference between groups when the indipedent var is numeric and outcome categorical.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncancerm <- melt(cancer, id.vars = \"diagnosis\")\n\nggplot(cancerm, aes(x = diagnosis, y = value))+\n    geom_boxplot() + facet_wrap(~variable, scales = \"free_y\")\n```\n:::\n\n\n## Split test, train\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_row <- nrow(cancer)\ntrain_size <- (0.7 * n_row) %>% as.integer()\ntrain_ids <- sample(1:n_row, train_size)\ntrain_data <- cancer[train_ids, ]\ntest_data <- cancer\ntest_pat_id <- pat_id[-train_ids]\n```\n:::\n\n\n## Fit xgboost, random forest,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncv_fold <- createFolds(train_data$diagnosis, k = 10)\ntrain_ctrl <- trainControl(method = \"cv\",\n                        number = 10,\n                        summaryFunction = twoClassSummary,\n                        classProbs = TRUE,\n                        allowParallel=T,\n                        index = cv_fold,\n                        verboseIter = FALSE,\n                        savePredictions = TRUE,\n                        search = \"grid\")\n\nxgb_grid <- expand.grid(nrounds = c(10, 50, 100),\n                        eta = seq(0.06, .2, length.out = 3),\n                        max_depth = c( 5, 10),\n                        gamma = c(0,.01, 0.1),\n                        colsample_bytree = c(0.6, 0.7,0.8),\n                        min_child_weight = c(0.7, 0.95),\n                        subsample =  c(0.5, 0.7, 0.9))\n\ntrees_ranger <-  seq(from = 5, to = (ncol(cancer) - 1),\n                     length.out = 5 ) %>% as.integer()\n\nranger_grid <- expand.grid(splitrule = c(\"extratrees\", \"gini\"),\n                        mtry = trees_ranger,\n                        min.node.size = c(0.85, .95))\n\nsvm_grid <- expand.grid(C = c(0.5, 1, 10),\n                        sigma = seq(0.001, 0.1, length.out = 10))\n```\n:::\n\n\n## Fit Random forest\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(caretEnsemble)\nlibrary(foreach)\nlibrary(doParallel) # ignore  it's used for parallel\nlibrary(tictoc) # ignore it's used for timing\ncl <- makeCluster(3)\nregisterDoParallel(cl)\ntic()\nset.seed(100)\n\n\nrf  <- caret::train(\n  diagnosis~.,\n  data= train_data,\n  trControl=train_ctrl,\n  metric = \"ROC\",\n  method = \"ranger\",\n  tuneGrid= ranger_grid)\n\ntoc()\n\nregisterDoSEQ()\n\nrf\n```\n:::\n\n\n## Calculate Shap values\n\n-   use the shapper package it uses python shap package so you must have python installed + python shap library\n-   https://github.com/ModelOriented/shapper\n-   install from cran\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shapper)\n# X_pred <- train_data[, .SD, .SDcols = !c(\"diagnosis\")] %>%\n#   as.data.frame() # this because i use data.table\n# \n# tic()\n# p_function <- function(model, data) predict(model, newdata = data, type = \"prob\")\n# shap_values <- individual_variable_effect(rf, data = X_pred, predict_function = p_function,\n#                                      new_observation = X_pred, nsamples = 150)\n# \n# \n# toc()\ntic()\n\ntic()\n\nshap_list <- foreach(i = 1:nrow(X_pred)) %do%{\n    shap <- Shapley$new(predictor,  x.interest = X_pred[i, ], sample.size = 150)\n    shap_import <-shap$results %>% data.table()\n    shap_import <- shap_import[class == \"M\"]\n    shap_import[,id := pat_id[i]]\n    \n}\ntoc()\n\n\ntoc()\n\nshap_values <- rbindlist(shap_list)\nwrite.csv(shap_values, file =\"shap_values3.csv\", row.names = F )\n```\n:::\n\n\n## Shap plots\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggforce)\nshap_values <-  fread(\"shap_values3.csv\")\n\nsetnames(shap_values, c(\"_attribution_\", \"_vname_\"), c(\"phi\",\"feature\" ))\nshap_values[, phi2 := abs( phi )]\nshap_imp <- shap_values[, .(Med = median(phi2),\n                            Mean = mean(phi2)), by = feature] %>%\n    setorder(-Med)\nshap_imp <- shap_imp[1:30, ]\n\nshap_values <- shap_values[feature %in%shap_imp$feature]\n\nshap_values[, feature := factor(feature, levels = rev(shap_imp$feature) )]\n\nggplot(shap_values, aes(feature, phi,  color = abs(phi)))+\n  geom_sina()+\n  geom_hline(yintercept = 0) +\n  scale_color_gradient(name = \"\",low=\"#2187E3\", high=\"#F32858\", \n                       breaks=c(0,.2), labels=c(\"Low\",\"High\"),\n                       limits = c(0,.2))+ \n  theme_bw() + \n    theme(axis.line.y = element_blank(), \n          axis.ticks.y = element_blank(), # remove axis line\n          legend.position=\"bottom\") +\n  coord_flip()\n```\n:::\n\n\n## Fit models using caret ensembles\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Ignore; just a simpler if you want to compare models perfomance\n\n# cl <- makeCluster(3)\n# registerDoParallel(cl)\n# tic()\n# set.seed(100)\n# model_list <- caretList(\n#    diagnosis~.,\n#     data= train_data,\n#     trControl=train_ctrl,\n#     metric = \"ROC\",\n#     tuneList = list(caretModelSpec(method=\"xgbTree\",  tuneGrid= xgb_grid),\n#                     caretModelSpec(method = \"svmRadial\", tuneGrid = svm_grid),\n#                     caretModelSpec(method=\"ranger\", tuneGrid= ranger_grid)\n# \n#                    \n#                     \n#                     )\n# )\n# \n# toc()\n# \n# registerDoSEQ()\n# \n# model_list\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}