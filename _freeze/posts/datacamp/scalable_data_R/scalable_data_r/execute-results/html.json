{
  "hash": "ff44ec09c8a447d98da7f484f2a0440a",
  "result": {
    "markdown": "---\ntitle: \"Scalable Data Processing in R\"\nauthor: \"Mburu\"\ndate: \"4/13/2021\"\noutput: html_document\n---\n\n\n\n\n## How does processing time vary by data size?\n\nIf you are processing all elements of two data sets, and one data set is bigger, then the bigger data set will take longer to process. However, it's important to realize that how much longer it takes is not always directly proportional to how much bigger it is. That is, if you have two data sets and one is two times the size of the other, it is not guaranteed that the larger one will take twice as long to process. It could take 1.5 times longer or even four times longer. It depends on which operations are used to process the data set.\n\nIn this exercise, you'll use the microbenchmark package, which was covered in the Writing Efficient R Code course.\n\nNote: Numbers are specified using scientific notation\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the microbenchmark package\nlibrary(microbenchmark)\n\n# Compare the timings for sorting different sizes of vector\nmb <- microbenchmark(\n  # Sort a random normal vector length 1e5\n  \"1e5\" = sort(rnorm(1e5)),\n  # Sort a random normal vector length 2.5e5\n  \"2.5e5\" = sort(rnorm(2.5e5)),\n  # Sort a random normal vector length 5e5\n  \"5e5\" = sort(rnorm(5e5)),\n  \"7.5e5\" = sort(rnorm(7.5e5)),\n  \"1e6\" = sort(rnorm(1e6)),\n  times = 10\n)\n\n# Plot the resulting benchmark object\nplot(mb)\n```\n\n::: {.cell-output-display}\n![](scalable_data_r_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n## Reading a big.matrix object\n\nIn this exercise, you'll create your first file-backed big.matrix object using the read.big.matrix() function. The function is meant to look similar to read.table() but, in addition, it needs to know what type of numeric values you want to read (\"char\", \"short\", \"integer\", \"double\"), it needs the name of the file that will hold the matrix's data (the backing file), and it needs the name of the file to hold information about the matrix (a descriptor file). The result will be a file on the disk holding the value read in along with a descriptor file which holds extra information (like the number of columns and rows) about the resulting big.matrix object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the bigmemory package\nlibrary(bigmemory)\n\n# Create the big.matrix object: x\nx <- read.big.matrix(\"mortgage-sample.csv\", header = TRUE, \n                     type = \"integer\", \n                     backingfile = \"mortgage-sample.bin\", \n                     descriptorfile = \"mortgage-sample.desc\")\n    \n# Find the dimensions of x\ndim(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 70000    16\n```\n:::\n:::\n\n\n## Attaching a big.matrix object\n\nNow that the big.matrix object is on the disk, we can use the information stored in the descriptor file to instantly make it available during an R session. This means that you don't have to reimport the data set, which takes more time for larger files. You can simply point the bigmemory package at the existing structures on the disk and begin accessing data without the wait.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Attach mortgage-sample.desc\nmort <- attach.big.matrix(\"mortgage-sample.desc\")\n\n# Find the dimensions of mort\ndim(mort)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 70000    16\n```\n:::\n\n```{.r .cell-code}\n# Look at the first 6 rows of mort\nhead(mort)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     enterprise record_number msa perc_minority tract_income_ratio\n[1,]          1           566   1             1                  3\n[2,]          1           116   1             3                  2\n[3,]          1           239   1             2                  2\n[4,]          1            62   1             2                  3\n[5,]          1           106   1             2                  3\n[6,]          1           759   1             3                  3\n     borrower_income_ratio loan_purpose federal_guarantee borrower_race\n[1,]                     1            2                 4             3\n[2,]                     1            2                 4             5\n[3,]                     3            8                 4             5\n[4,]                     3            2                 4             5\n[5,]                     3            2                 4             9\n[6,]                     2            2                 4             9\n     co_borrower_race borrower_gender co_borrower_gender num_units\n[1,]                9               2                  4         1\n[2,]                9               1                  4         1\n[3,]                5               1                  2         1\n[4,]                9               2                  4         1\n[5,]                9               3                  4         1\n[6,]                9               1                  2         2\n     affordability year type\n[1,]             3 2010    1\n[2,]             3 2008    1\n[3,]             4 2014    0\n[4,]             4 2009    1\n[5,]             4 2013    1\n[6,]             4 2010    1\n```\n:::\n:::\n",
    "supporting": [
      "scalable_data_r_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}