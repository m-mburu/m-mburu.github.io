{
  "hash": "c9f57edf246357ad6116d5b764bd91f0",
  "result": {
    "markdown": "---\ntitle: \"Census data in r with tidycensus\"\noutput: github_document\n---\n\n\n\n\n## Obtain and set your Census API key\n\ntidycensus is an R package designed to return data from the US Census Bureau ready for use within the Tidyverse.\n\nTo acquire data from the US Census Bureau using the tidycensus R package, you must first acquire and set a Census API key. After obtaining your key, you can install it for future use with the census_api_key() function in tidycensus.\n\nThis exercise uses a fake API key for purposes of illustration.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the tidycensus package into your R session\nlibrary(tidycensus)\nlibrary(tidyverse)\nlibrary(data.table)\nlibrary(tigris)\nlibrary(here)\n\n# Define your Census API key and set it with census_api_key()\napi_key <- Sys.getenv(\"CENSUS_API_KEY\")\n\ncensus_api_key(api_key)\n```\n:::\n\n\n##Setting a cache directory Spatial data from the US Census Bureau can get very big - sometimes hundreds of megabytes in size. By default, tigris functions download data from the US Census Bureau's website - but this can get tiresome if downloading the same large datasets over and over. To resolve this, tigris includes an option to cache downloaded data on a user's computer for future use, meaning that files only have to be downloaded from the Census website once. In this exercise, you'll get acquainted with the caching functionality in tigris.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set the cache directory\ntigris_cache_dir(here(\"tigris_cache\"))\n\n# Set the tigris_use_cache option\noptions(tigris_use_cache = TRUE)\n\n# Check to see that you've modified the option correctly\ngetOption(\"tigris_use_cache\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n## Getting Census data with tidycensus\n\nIn this exercise, you will load and inspect data from the 2010 US Census and 2012-2016 American Community Survey. The core functions of get_decennial() and get_acs() in tidycensus are used to obtain data from these sources; the 2010 Census and 2012-2016 ACS are the defaults for these functions, respectively.\n\nBy inspecting the data, you'll get a sense of differences between decennial US Census data and data from the ACS, which is based on a sample and subject to a margin of error. Whereas get_decennial() returns a data value for each row, get_acs() returns estimate and moe columns representing the ACS estimate and margin of error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Obtain and view state populations from the 2010 US Census\nstate_pop <- get_decennial(geography = \"state\", \n                           variables = \"P001001\")\n\nhead(state_pop)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  GEOID NAME       variable    value\n  <chr> <chr>      <chr>       <dbl>\n1 01    Alabama    P001001   4779736\n2 02    Alaska     P001001    710231\n3 04    Arizona    P001001   6392017\n4 05    Arkansas   P001001   2915918\n5 06    California P001001  37253956\n6 22    Louisiana  P001001   4533372\n```\n:::\n\n```{.r .cell-code}\n# Obtain and view state median household income from the 2012-2016 American Community Survey\nstate_income <- get_acs(geography = \"state\", \n                        variables = \"B19013_001\")\n\nhead(state_income)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  GEOID NAME       variable   estimate   moe\n  <chr> <chr>      <chr>         <dbl> <dbl>\n1 01    Alabama    B19013_001    54943   377\n2 02    Alaska     B19013_001    80287  1113\n3 04    Arizona    B19013_001    65913   387\n4 05    Arkansas   B19013_001    52123   458\n5 06    California B19013_001    84097   236\n6 08    Colorado   B19013_001    80184   450\n```\n:::\n:::\n\n\n## Understanding tidycensus options\n\nAs discussed in this lesson, Census data comprise thousands of variables available across dozens of geographies! Most of these geography-variable combinations are accessible with tidycensus; however, it helps to understand the package options.\n\nSome data, like Census tracts, are only available by state, and users might want to subset by county; tidycensus facilitates this with state and county parameters when appropriate. Additionally, tidycensus includes the Census variable ID in the variable column; however, a user might want to supply her own variable name, which can be accomplished with a named vector.\n\nYou'll be using the Census variable B19013_001 here, which refers to median household income.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get an ACS dataset for Census tracts in Texas by setting the state\ntx_income <- get_acs(geography = \"tract\",\n                     variables = \"B19013_001\",\n                     state = \"TX\")\n\n# Inspect the dataset\nhead(tx_income)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  GEOID       NAME                                         varia…¹ estim…²   moe\n  <chr>       <chr>                                        <chr>     <dbl> <dbl>\n1 48001950100 Census Tract 9501, Anderson County, Texas    B19013…   61325  9171\n2 48001950401 Census Tract 9504.01, Anderson County, Texas B19013…   92813 45136\n3 48001950402 Census Tract 9504.02, Anderson County, Texas B19013…      NA    NA\n4 48001950500 Census Tract 9505, Anderson County, Texas    B19013…   41713  6650\n5 48001950600 Census Tract 9506, Anderson County, Texas    B19013…   32552 12274\n6 48001950700 Census Tract 9507, Anderson County, Texas    B19013…   35811  5573\n# … with abbreviated variable names ¹​variable, ²​estimate\n```\n:::\n\n```{.r .cell-code}\n# Get an ACS dataset for Census tracts in Travis County, TX\ntravis_income <- get_acs(geography = \"tract\",\n                         variables = \"B19013_001\", \n                         state = \"TX\",\n                         county = \"Travis\")\n\n# Inspect the dataset\nhead(travis_income)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  GEOID       NAME                                    variable   estimate   moe\n  <chr>       <chr>                                   <chr>         <dbl> <dbl>\n1 48453000101 Census Tract 1.01, Travis County, Texas B19013_001   121964 31935\n2 48453000102 Census Tract 1.02, Travis County, Texas B19013_001   201417 26672\n3 48453000203 Census Tract 2.03, Travis County, Texas B19013_001    81994 14344\n4 48453000204 Census Tract 2.04, Travis County, Texas B19013_001    93219 26118\n5 48453000205 Census Tract 2.05, Travis County, Texas B19013_001    75000 24198\n6 48453000206 Census Tract 2.06, Travis County, Texas B19013_001    88342 10549\n```\n:::\n\n```{.r .cell-code}\n# Supply custom variable names\ntravis_income2 <- get_acs(geography = \"tract\", \n                          variables = c(hhincome = \"B19013_001\"), \n                          state = \"TX\",\n                          county = \"Travis\")\n\n# Inspect the dataset\nhead(travis_income2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  GEOID       NAME                                    variable estimate   moe\n  <chr>       <chr>                                   <chr>       <dbl> <dbl>\n1 48453000101 Census Tract 1.01, Travis County, Texas hhincome   121964 31935\n2 48453000102 Census Tract 1.02, Travis County, Texas hhincome   201417 26672\n3 48453000203 Census Tract 2.03, Travis County, Texas hhincome    81994 14344\n4 48453000204 Census Tract 2.04, Travis County, Texas hhincome    93219 26118\n5 48453000205 Census Tract 2.05, Travis County, Texas hhincome    75000 24198\n6 48453000206 Census Tract 2.06, Travis County, Texas hhincome    88342 10549\n```\n:::\n:::\n\n\n## Tidy and wide data in tidycensus\n\nBy default, tidycensus functions return tidy data frames, in which each row represents a unique unit-variable combination. However, at times it is useful to have each Census variable in its own column for some methods of visualization and analysis. To accomplish this, you can set output = \"wide\" in your calls to get_acs() or get_decennial(), which will place estimates/values and margins of error in their own columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Return county data in wide format\nor_wide <- get_acs(geography = \"county\", \n                     state = \"OR\",\n                     variables = c(hhincome = \"B19013_001\", \n                            medage = \"B01002_001\"), \n                     output = \"wide\")\n\n# Compare output to the tidy format from previous exercises\nhead(or_wide)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  GEOID NAME                     hhincomeE hhincomeM medageE medageM\n  <chr> <chr>                        <dbl>     <dbl>   <dbl>   <dbl>\n1 41001 Baker County, Oregon         46922      3271    47.7     0.9\n2 41003 Benton County, Oregon        68732      2689    33.3     0.3\n3 41005 Clackamas County, Oregon     88517      1424    41.6     0.2\n4 41007 Clatsop County, Oregon       61846      2651    44.5     0.4\n5 41009 Columbia County, Oregon      73909      3517    43.3     0.4\n6 41011 Coos County, Oregon          52548      3145    48.4     0.3\n```\n:::\n\n```{.r .cell-code}\n# Create a scatterplot\nplot(or_wide$hhincomeE, or_wide$medageE)\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-5-1.png){width=4200}\n:::\n:::\n\n\n## Loading variables in tidycensus\n\nThere are hundreds of thousands of variables in the decennial Census and American Community Survey samples, which can make it difficult to know which variable codes to use! tidycensus aims to make this easier with the load_variables() function, which obtains a dataset of variables from a specified sample and loads it into R as a browsable data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load variables from the 2012-2016 ACS\nv16 <- load_variables(year = 2016,\n           dataset = \"acs5\",\n           cache = TRUE)\n\n# Get variables from the ACS Data Profile\nv16p <- load_variables(year = 2016,\n                       dataset = \"acs5/profile\",\n                       cache = TRUE)\n\n# Set year and dataset to get variables from the 2000 Census SF3\nv00 <- load_variables(year = 2000,\n                      dataset = \"sf3\",\n                      cache = TRUE)\n```\n:::\n\n\n## Exploring variables with tidyverse tools\n\nOnce loaded, your dataset of Census or ACS variables might contain thousands of rows. In RStudio, it is recommended to use the View() function to interactively search for these variables. Outside of RStudio, these datasets can be browsed using tidyverse filtering tools.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filter for table B19001\nfilter(v16, str_detect(name, \"B19001\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 170 × 4\n   name        label                               concept               geogr…¹\n   <chr>       <chr>                               <chr>                 <chr>  \n 1 B19001A_001 Estimate!!Total                     HOUSEHOLD INCOME IN … tract  \n 2 B19001A_002 Estimate!!Total!!Less than $10,000  HOUSEHOLD INCOME IN … tract  \n 3 B19001A_003 Estimate!!Total!!$10,000 to $14,999 HOUSEHOLD INCOME IN … tract  \n 4 B19001A_004 Estimate!!Total!!$15,000 to $19,999 HOUSEHOLD INCOME IN … tract  \n 5 B19001A_005 Estimate!!Total!!$20,000 to $24,999 HOUSEHOLD INCOME IN … tract  \n 6 B19001A_006 Estimate!!Total!!$25,000 to $29,999 HOUSEHOLD INCOME IN … tract  \n 7 B19001A_007 Estimate!!Total!!$30,000 to $34,999 HOUSEHOLD INCOME IN … tract  \n 8 B19001A_008 Estimate!!Total!!$35,000 to $39,999 HOUSEHOLD INCOME IN … tract  \n 9 B19001A_009 Estimate!!Total!!$40,000 to $44,999 HOUSEHOLD INCOME IN … tract  \n10 B19001A_010 Estimate!!Total!!$45,000 to $49,999 HOUSEHOLD INCOME IN … tract  \n# … with 160 more rows, and abbreviated variable name ¹​geography\n```\n:::\n\n```{.r .cell-code}\n# Use public transportation to search for related variables\nfilter(v16p, str_detect(label, fixed(\"public transportation\", \n                                ignore_case = TRUE)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  name       label                                                       concept\n  <chr>      <chr>                                                       <chr>  \n1 DP03_0021  Estimate!!COMMUTING TO WORK!!Workers 16 years and over!!Pu… SELECT…\n2 DP03_0021P Percent!!COMMUTING TO WORK!!Workers 16 years and over!!Pub… SELECT…\n```\n:::\n:::\n\n\n## Comparing geographies with ggplot2 visualizations\n\nWhen exploring Census or ACS data, you'll often want to know how data varies among different geographic units. For example - which US states have higher - or lower - median household incomes? This can be accomplished through visualization using dot plots, which are particularly effective for showing ranks visually. In this exercise, you'll use the popular ggplot2 data visualization package to accomplish this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access the 1-year ACS  with the survey parameter\nne_income <- get_acs(geography = \"state\",\n                     variables = \"B19013_001\", \n                     survey = \"acs1\", \n                     state = c(\"ME\", \"NH\", \"VT\", \"MA\", \n                               \"RI\", \"CT\", \"NY\"))\n\n# Create a dot plot\n\n  \n# Reorder the states in descending order of estimates\nggplot(ne_income, aes(x = estimate, y = reorder(NAME, estimate))) + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-8-1.png){width=4200}\n:::\n:::\n\n\n## Customizing ggplot2 visualizations of ACS data\n\nWhile the ggplot2 defaults are excellent for exploratory visualization of data, you'll likely want to customize your charts before sharing them with others. In this exercise, you'll customize your tidycensus dot plot by modifying the chart colors, tick labels, and axis labels. You'll also learn how to format labels using the scales package, as label formatters can be imported using the :: syntax.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set dot color and size\ng_color <- ggplot(ne_income, aes(x = estimate, y = reorder(NAME, estimate))) + \n  geom_point(color = \"navy\", size = 4)\n\n# Format the x-axis labels\ng_scale <- g_color + \n  scale_x_continuous(labels = scales::dollar) + \n  theme_minimal(base_size = 12) \n\n# Label your x-axis, y-axis, and title your chart\ng_label <- g_scale + \n  labs(x =\"2016 ACS estimate\", \n       y = \"\", \n       title = \"Median household income by state\")\n  \ng_label\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-9-1.png){width=4800}\n:::\n:::\n\n\n## Download and view a table of data from the ACS\n\nVariables in the decennial Census and American Community Survey are organized into tables, within which they share a common prefix. Commonly, analysts will want to work with all variables in a given table, as these variables might represent different aspects of a common characteristic (such as race or income levels). To request data for an entire table in tidycensus, users can specify a table argument with the table prefix, and optionally cache a dataset of table codes to speed up table searching in future requests. In this exercise, you'll acquire a table of variables representing different income bands, then filter out the denominator rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Download table \"B19001\"\nwa_income <- get_acs(geography = \"county\", \n                 state = \"WA\", \n                 table = \"B19001\")\n\n# Check out the first few rows of wa_income\nhead(wa_income)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  GEOID NAME                     variable   estimate   moe\n  <chr> <chr>                    <chr>         <dbl> <dbl>\n1 53001 Adams County, Washington B19001_001     6158   123\n2 53001 Adams County, Washington B19001_002      474   171\n3 53001 Adams County, Washington B19001_003      255   107\n4 53001 Adams County, Washington B19001_004      204    90\n5 53001 Adams County, Washington B19001_005      393   134\n6 53001 Adams County, Washington B19001_006      358   159\n```\n:::\n:::\n\n\n## Get a summary variable and calculate percentages\n\nMany variables in the Census and American Community Survey are represented as counts or estimated counts. While count data is useful for some applications, it is often good practice to normalize count data by its denominator to convert it to a proportion or percentage to make clearer comparisons. This is facilitated in tidycensus with the summary_var argument, which allows users to request that a variable is given its own column in a tidy Census dataset. This value can then be used as the denominator for subsequent calculations of percentages.\n\nSummary question: When the summary_var parameter is requested in get_acs(), what information is returned by the function?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assign Census variables vector to race_vars \nrace_vars <- c(White = \"B03002_003\", Black = \"B03002_004\", Native = \"B03002_005\", \n               Asian = \"B03002_006\", HIPI = \"B03002_007\", Hispanic = \"B03002_012\")\n\n# Request a summary variable from the ACS\nca_race <- get_acs(geography = \"county\", \n                   state = \"CA\",\n                   variables = race_vars, \n                   summary_var = \"B03002_001\")\n\n# Calculate a new percentage column and check the result\nca_race_pct <- ca_race %>%\n  mutate(pct = 100 * (estimate / summary_est))\n\nhead(ca_race_pct)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 8\n  GEOID NAME                       variable estim…¹   moe summa…² summa…³    pct\n  <chr> <chr>                      <chr>      <dbl> <dbl>   <dbl>   <dbl>  <dbl>\n1 06001 Alameda County, California White     499730   988 1673133      NA 29.9  \n2 06001 Alameda County, California Black     166017  1837 1673133      NA  9.92 \n3 06001 Alameda County, California Native      5248   318 1673133      NA  0.314\n4 06001 Alameda County, California Asian     524980  2437 1673133      NA 31.4  \n5 06001 Alameda County, California HIPI       12699   566 1673133      NA  0.759\n6 06001 Alameda County, California Hispanic  374542    NA 1673133      NA 22.4  \n# … with abbreviated variable names ¹​estimate, ²​summary_est, ³​summary_moe\n```\n:::\n:::\n\n\n## Finding the largest group by county\n\ntidyverse data wrangling tools in packages like dplyr and purrr are extremely powerful for exploring Census data. tidycensus is specifically designed with data exploration within the tidyverse in mind. For example, users might be interested in finding out the largest racial/ethnic group within each county for a given state. This can be accomplished using dplyr grouping capabilities, which allow users to identify the largest ACS group estimate and filter to retain the rows that match that group.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group the dataset and filter the estimate\nca_largest <- ca_race %>%\n  group_by(GEOID) %>%\n  filter(estimate == max(estimate)) \n\nhead(ca_largest)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 7\n# Groups:   GEOID [6]\n  GEOID NAME                         variable estimate   moe summary_est summa…¹\n  <chr> <chr>                        <chr>       <dbl> <dbl>       <dbl>   <dbl>\n1 06001 Alameda County, California   Asian      524980  2437     1673133      NA\n2 06003 Alpine County, California    White         730   153        1344     228\n3 06005 Amador County, California    White       30081   412       40095      NA\n4 06007 Butte County, California     White      153153   300      217884      NA\n5 06009 Calaveras County, California White       35925   129       45349      NA\n6 06011 Colusa County, California    Hispanic    13177    NA       21780      NA\n# … with abbreviated variable name ¹​summary_moe\n```\n:::\n\n```{.r .cell-code}\n# Group the dataset and get a breakdown of the results\nca_largest %>% \n  group_by(variable) %>%\n  tally()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  variable     n\n  <chr>    <int>\n1 Asian        2\n2 Hispanic    16\n3 White       40\n```\n:::\n:::\n\n\n## Recoding variables and calculating group sums\n\ndplyr, one of the core packages within the tidyverse, includes numerous functions for data wrangling. This functionality allows users to recode datasets, define groups within those datasets, and perform calculations over those groups. Such operations commonly take place within a pipe, denoted with the %\\>% operator.\n\nIn this exercise, you'll work with ACS data in just such a tidyverse workflow. You'll be identifying median household income variables in ACS table B19001 that are below \\$35,000; between \\$35,000 and \\$75,000; and above \\$75,000. You'll then tabulate the number of households that fall into each group for counties in Washington.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use a tidy workflow to wrangle ACS data\nwa_grouped <- wa_income %>%\n  filter(variable != \"B19001_001\") %>%\n  mutate(incgroup = case_when(\n    variable < \"B19001_008\" ~ \"below35k\", \n    variable < \"B19001_013\" ~ \"35kto75k\", \n    TRUE ~ \"above75k\"\n  )) %>%\n  group_by(NAME, incgroup) %>%\n  summarize(group_est = sum(estimate))\n\nwa_grouped\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 117 × 3\n# Groups:   NAME [39]\n   NAME                      incgroup group_est\n   <chr>                     <chr>        <dbl>\n 1 Adams County, Washington  35kto75k      2156\n 2 Adams County, Washington  above75k      2094\n 3 Adams County, Washington  below35k      1908\n 4 Asotin County, Washington 35kto75k      3215\n 5 Asotin County, Washington above75k      3537\n 6 Asotin County, Washington below35k      2535\n 7 Benton County, Washington 35kto75k     21285\n 8 Benton County, Washington above75k     37911\n 9 Benton County, Washington below35k     15094\n10 Chelan County, Washington 35kto75k      9163\n# … with 107 more rows\n```\n:::\n:::\n\n\n## Comparing ACS estimates for multiple years\n\nThe American Community Survey is updated every year, which allows researchers to use ACS datasets to study demographic changes over time.\n\nIn this exercise, you'll learn how to use the tidyverse function map_df() to work with multi-year ACS data. map_df() helps analysts iterate through a sequence of values, compute a process for each of those values, then combine the results into a single data frame. You'll be using map_df() in this way with ACS data, as you iterate through a vector of years, retrieve ACS data for each year, and combine the results. This will allow you to view how ACS estimates have changed over time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Map through ACS1 estimates to see how they change through the years\nmi_cities <- map_df(2012:2016, function(x) {\n  get_acs(geography = \"place\", \n          variables = c(totalpop = \"B01003_001\"), \n          state = \"MI\", \n          survey = \"acs1\", \n          year = x) %>%\n    mutate(year = x)\n})\n\nmi_cities %>% arrange(NAME, year)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 80 × 6\n   GEOID   NAME                     variable estimate   moe  year\n   <chr>   <chr>                    <chr>       <dbl> <dbl> <int>\n 1 2603000 Ann Arbor city, Michigan totalpop   116128    35  2012\n 2 2603000 Ann Arbor city, Michigan totalpop   117034    43  2013\n 3 2603000 Ann Arbor city, Michigan totalpop   117759    44  2014\n 4 2603000 Ann Arbor city, Michigan totalpop   117070    33  2015\n 5 2603000 Ann Arbor city, Michigan totalpop   120777    33  2016\n 6 2621000 Dearborn city, Michigan  totalpop    96470    28  2012\n 7 2621000 Dearborn city, Michigan  totalpop    95888    35  2013\n 8 2621000 Dearborn city, Michigan  totalpop    95546    48  2014\n 9 2621000 Dearborn city, Michigan  totalpop    95180    40  2015\n10 2621000 Dearborn city, Michigan  totalpop    94430    52  2016\n# … with 70 more rows\n```\n:::\n:::\n\n\n## Inspecting margins of error\n\nACS data are distinct from decennial Census data in that they represent estimates with an associated margin of error. ACS margins of error by default represent a 90 percent confidence level around an estimate, which means that we are 90 percent sure that the true value falls within a range of the reported estimate plus or minus the reported margin of error.\n\nIn this exercise, you'll get some experience working with data that has high margins of error relative to their estimates. We'll use the example of poverty for the population aged 75 and above for Census tracts in Vermont.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get data on elderly poverty by Census tract in Vermont\nvt_eldpov <- get_acs(geography = \"tract\", \n                     variables = c(eldpovm = \"B17001_016\", \n                                   eldpovf = \"B17001_030\"), \n                     state = \"VT\")\n\nvt_eldpov\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 386 × 5\n   GEOID       NAME                                       variable estim…¹   moe\n   <chr>       <chr>                                      <chr>      <dbl> <dbl>\n 1 50001960100 Census Tract 9601, Addison County, Vermont eldpovm        2     5\n 2 50001960100 Census Tract 9601, Addison County, Vermont eldpovf        8     7\n 3 50001960200 Census Tract 9602, Addison County, Vermont eldpovm        4     6\n 4 50001960200 Census Tract 9602, Addison County, Vermont eldpovf        0    10\n 5 50001960300 Census Tract 9603, Addison County, Vermont eldpovm        0    10\n 6 50001960300 Census Tract 9603, Addison County, Vermont eldpovf        7     9\n 7 50001960400 Census Tract 9604, Addison County, Vermont eldpovm        7    10\n 8 50001960400 Census Tract 9604, Addison County, Vermont eldpovf       15    11\n 9 50001960500 Census Tract 9605, Addison County, Vermont eldpovm        6    10\n10 50001960500 Census Tract 9605, Addison County, Vermont eldpovf       14    16\n# … with 376 more rows, and abbreviated variable name ¹​estimate\n```\n:::\n\n```{.r .cell-code}\n# Identify rows with greater margins of error than their estimates\nmoe_check <- filter(vt_eldpov, moe > estimate)\n\n# Check proportion of rows where the margin of error exceeds the estimate\nnrow(moe_check) / nrow(vt_eldpov)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.7927461\n```\n:::\n:::\n\n\n## Using margin of error functions in tidycensus\n\nWhile the Census Bureau API and tidycensus return pre-computed margins of error for you, you may want to derive new estimates from downloaded ACS data and in turn understand the margins of error around these derived estimates. tidycensus includes four functions (listed below) to help you with these tasks, each of which incorporates the recommended formulas from the US Census Bureau.\n\nmoe_sum() moe_product() moe_ratio() moe_prop()\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate a margin of error for a sum\nmoe_sum(moe = c(55, 33, 44, 12, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 78.80355\n```\n:::\n\n```{.r .cell-code}\n# Calculate a margin of error for a product\nmoe_product(est1 = 55,\n    est2 = 33,\n    moe1 = 12,\n    moe2 = 9)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 633.9093\n```\n:::\n\n```{.r .cell-code}\n# Calculate a margin of error for a ratio\nmoe_ratio(num = 1000,\n    denom = 950,\n    moe_num = 200,\n    moe_denom = 177)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.287724\n```\n:::\n\n```{.r .cell-code}\n# Calculate a margin of error for a proportion\nmoe_prop(num = 374,\n    denom = 1200,\n    moe_num = 122,\n    moe_denom = 333)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.05344178\n```\n:::\n:::\n\n\n## Calculating group-wise margins of error\n\nOne way to reduce margins of error in an ACS analysis is to combine estimates when appropriate. This can be accomplished using tidyverse group-wise data analysis tools. In this exercise, you'll combine estimates for male and female elderly poverty in Vermont, and use the moe_sum() function as part of this group-wise analysis. While you may lose some detail with this type of approach, your estimates will be more reliable relative to their margins of error than before you combined them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group the dataset and calculate a derived margin of error\nvt_eldpov2 <- vt_eldpov %>%\n  group_by(GEOID) %>%\n  summarize(\n    estmf = sum(estimate), \n    moemf = moe_sum(moe = moe, estimate = estimate)\n  )\n\n# Filter rows where newly-derived margin of error exceeds newly-derived estimate\nmoe_check2 <- filter(vt_eldpov2, moemf > estmf)\n\n# Check proportion of rows where margin of error exceeds estimate\nnrow(moe_check2) / nrow(vt_eldpov2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.626943\n```\n:::\n:::\n\n\n## Quick visual exploration of ACS margins of error\n\nIn Chapter 1, you learned how to create a dot plot of ACS income estimates. In this chapter, you've also learned about the importance of taking margins of error into account in ACS analyses. While margins of error are likely minimal for state-level estimates, they may be more significant for sub-state estimates, like counties. In this exercise, you'll learn how to visualize margins of error around estimates with ggplot2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Request median household income data\nmaine_inc <- get_acs(geography = \"county\", \n                     variables = c(hhincome = \"B19013_001\"), \n                     state = \"ME\") \n\n# Generate horizontal error bars with dots\nggplot(maine_inc, aes(x = estimate, y = NAME)) + \n  geom_errorbarh(aes(xmin = estimate - moe, xmax = estimate + moe)) + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-18-1.png){width=4200}\n:::\n:::\n\n\n## Customizing a ggplot2 margin of error plot\n\nYou've hopefully identified some problems with the chart you created in the previous exercise. As the counties are not ordered, patterns in the data are difficult for a viewer to parse. Specifically, margin of error plots are much more effective when dots are ordered as the ordering allows viewers to understand the uncertainty in estimate values relative to other estimates. Additionally, the lack of plot formatting makes it difficult for chart viewers to understand the chart's content. In this exercise, you'll clean up your ggplot2 code to create a much more visually appealing margin of error chart.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remove unnecessary content from the county's name\nmaine_inc2 <- maine_inc %>%\n  mutate(NAME = str_replace(NAME, \" County, Maine\", \"\"))\n\n# Build a margin of error plot incorporating your modifications\nggplot(maine_inc2, aes(x = estimate, y = reorder(NAME, estimate))) + \n  geom_errorbarh(aes(xmin = estimate - moe, xmax = estimate + moe)) + \n  geom_point(size = 3, color = \"darkgreen\") + \n  theme_grey(base_size = 14) + \n  labs(title = \"Median household income\", \n       subtitle = \"Counties in Maine\", \n       x = \"ACS estimate (bars represent margins of error)\", \n       y = \"\") + \n  scale_x_continuous(labels = scales::dollar)\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-19-1.png){width=4200}\n:::\n:::\n\n\n## Getting Census boundary files with tigris\n\nThe US Census Bureau's TIGER/Line shapefiles include boundary files for the geography at which decennial Census and ACS data are aggregated. These geographies include legal entities that have legal standing in the U.S., such as states and counties, and statistical entities used for data tabulation such as Census tracts and block groups. In this exercise, you'll use the tigris package to acquire such boundary files for counties in Colorado and Census tracts for Colorado's Denver County, which covers the city of Denver.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get a counties dataset for Colorado and plot it\nco_counties <- counties(state = \"CO\")\nplot(co_counties)\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-20-1.png){width=4200}\n:::\n\n```{.r .cell-code}\n# Get a Census tracts dataset for Denver County, Colorado and plot it\ndenver_tracts <- tracts(state = \"CO\", county = \"Denver\")\nplot(denver_tracts)\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-20-2.png){width=4200}\n:::\n:::\n\n\n## Getting geographic features with tigris\n\nIn addition to enumeration units, the TIGER/Line database produced by the Census Bureau includes geographic features. These features consist of several datasets for use in thematic mapping and spatial analysis, such as transportation infrastructure and water features. In this exercise, you'll acquire and plot roads and water data with tigris.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot area water features for Lane County, Oregon\nlane_water <- area_water(state = \"OR\", county = \"Lane\")\nplot(lane_water)\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-21-1.png){width=4200}\n:::\n\n```{.r .cell-code}\n# Plot primary & secondary roads for the state of New Hampshire\nnh_roads <- primary_secondary_roads(state = \"NH\")\nplot(nh_roads)\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-21-2.png){width=4200}\n:::\n:::\n\n\n## Understanding the structure of tigris objects\n\nBy default, tigris returns objects of class Spatial*DataFrame from the sp package. Objects of class Spatial* represent components of spatial data in different slots, which include descriptions of the object's geometry, attributes, and coordinate system. In this exercise, we'll briefly examine the structure of objects returned by tigris functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check the class of the data\nclass(co_counties)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sf\"         \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\n# Take a look at the information in the data slot\nhead(co_counties)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 6 features and 17 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -108.3811 ymin: 36.99961 xmax: -102.0448 ymax: 41.0026\nGeodetic CRS:  NAD83\n    STATEFP COUNTYFP COUNTYNS GEOID     NAME        NAMELSAD LSAD CLASSFP MTFCC\n23       08      109 00198170 08109 Saguache Saguache County   06      H1 G4020\n107      08      115 00198173 08115 Sedgwick Sedgwick County   06      H1 G4020\n124      08      017 00198124 08017 Cheyenne Cheyenne County   06      H1 G4020\n163      08      027 00198129 08027   Custer   Custer County   06      H1 G4020\n200      08      067 00198148 08067 La Plata La Plata County   06      H1 G4020\n228      08      111 00198171 08111 San Juan San Juan County   06      H1 G4020\n    CSAFP CBSAFP METDIVFP FUNCSTAT      ALAND   AWATER    INTPTLAT     INTPTLON\n23   <NA>   <NA>     <NA>        A 8206547699  4454510 +38.0316514 -106.2346662\n107  <NA>   <NA>     <NA>        A 1419419015  3530746 +40.8715679 -102.3553579\n124  <NA>   <NA>     <NA>        A 4605713960  8166129 +38.8356456 -102.6017914\n163  <NA>   <NA>     <NA>        A 1913031975  3364150 +38.1019955 -105.3735123\n200  <NA>  20420     <NA>        A 4376255277 25642579 +37.2873673 -107.8397178\n228  <NA>   <NA>     <NA>        A 1003660672  2035929 +37.7810492 -107.6702567\n                          geometry\n23  MULTIPOLYGON (((-105.8093 3...\n107 MULTIPOLYGON (((-102.2091 4...\n124 MULTIPOLYGON (((-102.547 38...\n163 MULTIPOLYGON (((-105.7969 3...\n200 MULTIPOLYGON (((-107.7124 3...\n228 MULTIPOLYGON (((-107.9751 3...\n```\n:::\n\n```{.r .cell-code}\n# Check the coordinate system of the data\n```\n:::\n\n\n## TIGER/Line and cartographic boundary files\n\nIn addition to its TIGER/Line shapefiles, the US Census Bureau releases cartographic boundary shapefiles for enumeration units. TIGER/Line shapefiles correspond to legal boundaries of units, which can include water area and in turn, may not be preferable for thematic mapping. The Census Bureau's cartographic boundary shapefiles are clipped to the US shoreline and are generalized, which can make them superior for mapping projects. In this exercise, you'll compare the TIGER/Line and cartographic boundary representations of the US state of Michigan.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get a counties dataset for Michigan\nmi_tiger <- counties(\"MI\")\n\n# Get the equivalent cartographic boundary shapefile\nmi_cb <- counties(\"MI\", cb = TRUE)\n\n# Overlay the two on a plot to make a comparison\nplot(mi_tiger)\nplot(mi_cb, add = TRUE, border = \"red\")\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-23-1.png){width=4200}\n:::\n:::\n\n\n## Getting data as simple features objects\n\nThe sf package, which stands for simple features, promises to revolutionize the way that vector spatial data are handled within R. sf objects represent spatial data much like regular data frames, with a list-column that contains the geometry of the geographic dataset. tigris can return spatial data as simple features objects either by declaring class = \"sf\" within a function call or by setting as a global option. In this exercise, you'll get acquainted with simple features in tigris.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get data from tigris as simple features\noptions(tigris_class = \"sf\")\n\n# Get countries from Colorado and view the first few rows\ncolorado_sf <- counties(\"CO\")\nhead(colorado_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 6 features and 17 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -108.3811 ymin: 36.99961 xmax: -102.0448 ymax: 41.0026\nGeodetic CRS:  NAD83\n    STATEFP COUNTYFP COUNTYNS GEOID     NAME        NAMELSAD LSAD CLASSFP MTFCC\n23       08      109 00198170 08109 Saguache Saguache County   06      H1 G4020\n107      08      115 00198173 08115 Sedgwick Sedgwick County   06      H1 G4020\n124      08      017 00198124 08017 Cheyenne Cheyenne County   06      H1 G4020\n163      08      027 00198129 08027   Custer   Custer County   06      H1 G4020\n200      08      067 00198148 08067 La Plata La Plata County   06      H1 G4020\n228      08      111 00198171 08111 San Juan San Juan County   06      H1 G4020\n    CSAFP CBSAFP METDIVFP FUNCSTAT      ALAND   AWATER    INTPTLAT     INTPTLON\n23   <NA>   <NA>     <NA>        A 8206547699  4454510 +38.0316514 -106.2346662\n107  <NA>   <NA>     <NA>        A 1419419015  3530746 +40.8715679 -102.3553579\n124  <NA>   <NA>     <NA>        A 4605713960  8166129 +38.8356456 -102.6017914\n163  <NA>   <NA>     <NA>        A 1913031975  3364150 +38.1019955 -105.3735123\n200  <NA>  20420     <NA>        A 4376255277 25642579 +37.2873673 -107.8397178\n228  <NA>   <NA>     <NA>        A 1003660672  2035929 +37.7810492 -107.6702567\n                          geometry\n23  MULTIPOLYGON (((-105.8093 3...\n107 MULTIPOLYGON (((-102.2091 4...\n124 MULTIPOLYGON (((-102.547 38...\n163 MULTIPOLYGON (((-105.7969 3...\n200 MULTIPOLYGON (((-107.7124 3...\n228 MULTIPOLYGON (((-107.9751 3...\n```\n:::\n\n```{.r .cell-code}\n# Plot its geometry column\nplot(colorado_sf$geometry)\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-24-1.png){width=4200}\n:::\n:::\n\n\n## Working with historic shapefiles\n\nTo ensure clean integration with the tidycensus package - which you'll learn about in the next chapter - tigris defaults to returning shapefiles that correspond to the year of the most recently-released ACS data. However, you may want boundary files for other years. tigris allows R users to obtain shapefiles for 1990, 2000, and 2010 through 2017, which represent many boundary changes over time. In this exercise, you'll use tigris to explore how Census tract boundaries have changed in Williamson County, Texas between 1990 and 2016.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get a historic Census tract shapefile from 1990 for Williamson County, Texas\nwilliamson90 <- tracts(state = \"TX\", county = \"Williamson\", \n                       cb = TRUE, year = 1990)\n\n# Compare with a current dataset for 2016\nwilliamson16 <- tracts(state = \"TX\", county = \"Williamson\", \n                       cb = TRUE, year = 2016)\n\n# Plot the geometry to compare the results                       \npar(mfrow = c(1, 2))\nplot(williamson90$geometry)\nplot(williamson16$geometry)\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-25-1.png){width=4200}\n:::\n:::\n\n\n## Combining datasets of the same tigris type\n\nOften, datasets from the US Census Bureau are available by state, which means they are available by state from tigris as well. In many instances, you'll want to combine datasets for multiple states. For example, an analysis of the Portland, Oregon metropolitan area would include areas in both Oregon and Washington north of the Columbia River; however, these areas are represented in different Census files. In this exercise, you'll learn how to combine datasets with the rbind_tigris() function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get Census tract boundaries for Oregon and Washington\nor_tracts <- tracts(\"OR\", cb = TRUE)\nwa_tracts <- tracts(\"WA\", cb = TRUE)\n\n# Check the tigris attributes of each object\nattr(or_tracts, \"tigris\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tract\"\n```\n:::\n\n```{.r .cell-code}\nattr(wa_tracts, \"tigris\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tract\"\n```\n:::\n\n```{.r .cell-code}\n# Combine the datasets then plot the result\nor_wa_tracts <- rbind_tigris(or_tracts, wa_tracts)\nplot(or_wa_tracts$geometry)\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-26-1.png){width=4200}\n:::\n:::\n\n\n## Getting data for multiple states\n\nIn the previous exercise, you learned how to combine datasets with the rbind_tigris() function. If you need data for more than two states, however, this process can get tedious. In this exercise, you'll learn how to generate a list of datasets for multiple states with the tidyverse map() function, and combine those datasets with rbind_tigris().\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate a vector of state codes and assign to new_england\nnew_england <- c(\"ME\", \"NH\", \"VT\", \"MA\")\n\n# Iterate through the states and request tract data for state\nne_tracts <- map(new_england, function(x) {\n  tracts(state = x, cb = TRUE)\n}) %>%\n  rbind_tigris()\n\nplot(ne_tracts$geometry)\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-27-1.png){width=4200}\n:::\n:::\n\n\n## Joining data from an external data frame\n\nWhen working with geographic data in R, you'll commonly want to join attribute information from an external dataset to it for mapping and spatial analysis. The sf package enables the use of the tidyverse \\*\\_join() functions for simple features objects for this purpose. In this exercise, you'll learn how to join data to a spatial dataset of legislative boundaries for the Texas House of Representatives that you've obtained using tigris.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get boundaries for Texas and set the house parameter\ntx_house <- state_legislative_districts(state = \"TX\", house = \"lower\", cb = TRUE)\n\n# Merge data on legislators to their corresponding boundaries\ntx_joined <- left_join(tx_house, tx_members, by = c(\"NAME\" = \"District\"))\n\nhead(tx_joined)\n```\n:::\n\n\n## Plotting simple features with geom_sf()\n\nThe newest version of ggplot2 includes a geom_sf() function to plot simple features objects natively. This allows you to make maps using familiar ggplot2 syntax! In this exercise, you'll walk through the process of creating a map with ggplot2 step-by-step.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot the legislative district boundaries\nggplot(tx_joined) + \n  geom_sf()\n\n# Set fill aesthetic to map areas represented by Republicans and Democrats\nggplot(tx_joined, aes(fill = Party)) + \n  geom_sf()\n\n# Set values so that Republican areas are red and Democratic areas are blue\nggplot(tx_joined, aes(fill = Party)) + \n  geom_sf() + \n  scale_fill_manual(values = c(\"R\" = \"red\", \"D\" = \"blue\"))\n```\n:::\n\n\n## Customizing geom_sf() plots\n\nAs you've learned in previous chapters, it is a good idea to clean up and format your ggplot2 visualizations before sharing with others. In this exercise, you'll make some modifications to your map of Texas House districts such as removing the gridlines and adding an informative title.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Draw a ggplot without gridlines and with an informative title\nggplot(tx_joined, aes(fill = Party)) + \n  geom_sf() + \n  coord_sf(crs = 3083, datum = NA) + \n  scale_fill_manual(values = c(\"R\" = \"red\", \"D\" = \"blue\")) + \n  theme_minimal(base_size = 16) + \n  labs(title = \"State House Districts in Texas\")\n```\n:::\n\n\n## Getting simple feature geometry\n\ntidycensus can obtain simple feature geometry for many geographies by adding the argument geometry = TRUE. In this exercise, you'll obtain a dataset of median housing values for owner-occupied units by Census tract in Orange County, California with simple feature geometry included.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidycensus)\nlibrary(tidyverse)\nlibrary(sf)\n\n# Get dataset with geometry set to TRUE\norange_value <- get_acs(geography = \"tract\", state = \"CA\", \n                    county = \"Orange\", \n                    variables = \"B25077_001\", \n                    geometry = TRUE)\n\n# Plot the estimate to view a map of the data\nplot(orange_value[\"estimate\"])\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-31-1.png){width=4200}\n:::\n:::\n\n\n## Joining data from tigris and tidycensus\n\nGeometry is currently supported in tidycensus for geographies in the core Census hierarchy - state, county, Census tract, block group, and block - as well as zip code tabulation areas. However, you may be interested in mapping data for other geographies. In this case, you can download the equivalent boundary file from the Census Bureau using the tigris package and join your demographic data to it for mapping.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get an income dataset for Idaho by school district\nidaho_income <- get_acs(geography = \"school district (unified)\", \n                        variables = \"B19013_001\", \n                        state = \"ID\")\n\n# Get a school district dataset for Idaho\nidaho_school <- school_districts(state = \"ID\", type = \"unified\", class = \"sf\")\n\n# Join the income dataset to the boundaries dataset\nid_school_joined <- left_join(idaho_school, idaho_income, by = \"GEOID\")\n\nplot(id_school_joined[\"estimate\"])\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-32-1.png){width=4200}\n:::\n:::\n\n\n## Shifting Alaska and Hawaii geometry\n\nAnalysts will commonly want to map data for the entire United States by state or county; however, this can be difficult by default as Alaska and Hawaii are distant from the continental United States. A common solution is to rescale and shift Alaska and Hawaii for mapping purposes, which is supported in tidycensus. You'll learn how to do this in this exercise.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get a dataset of median home values from the 1-year ACS\nstate_value <- get_acs(geography = \"state\", \n                       variables = \"B25077_001\", \n                       survey = \"acs1\", \n                       geometry = TRUE, \n                       shift_geo = TRUE)\n\n# Plot the dataset to view the shifted geometry\nplot(state_value[\"estimate\"])\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-33-1.png){width=4200}\n:::\n:::\n\n\n## Making a choropleth map\n\nChoropleth maps, which visualize statistical variation through the shading of areas, are among the most popular ways to map demographic data. Census or ACS data acquired with tidycensus can be mapped in this way in ggplot2 with geom_sf using the estimate column as a fill aesthetic. In this exercise, you'll make a choropleth map with ggplot2 of median owner-occupied home values by Census tract for Marin County, California.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a choropleth map with ggplot\nggplot(marin_value, aes(fill = estimate)) + \n  geom_sf()\n```\n:::\n\n\n## Modifying map colors\n\nggplot2 version 3.0 integrated the viridis color palettes, which are perceptually uniform and legible to colorblind individuals and in black and white. For these reasons, the viridis palettes have become very popular for data visualization, including for choropleth mapping. In this exercise, you'll learn how to use the viridis palettes for choropleth mapping in ggplot2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set continuous viridis palettes for your map\nggplot(marin_value, aes(fill = estimate, color = estimate)) + \n  geom_sf() + \n  scale_fill_viridis_c() +  \n  scale_color_viridis_c()\n```\n:::\n\n\n## Customizing the map output\n\nNow that you've chosen an appropriate color palette for your choropleth map of median home values by Census tract in Marin County, you'll want to customize the output. In this exercise, you'll clean up some map elements and add some descriptive information to provide context to your map.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set the color guide to FALSE and add a subtitle and caption to your map\nggplot(marin_value, aes(fill = estimate, color = estimate)) + \n  geom_sf() + \n  scale_fill_viridis_c(labels = scales::dollar) +  \n  scale_color_viridis_c(guide = FALSE) + \n  theme_minimal() + \n  coord_sf(crs = 26911, datum = NA) + \n  labs(title = \"Median owner-occupied housing value by Census tract\", \n       subtitle = \"Marin County, California\", \n       caption = \"Data source: 2012-2016 ACS.\\nData acquired with the R tidycensus package.\", \n       fill = \"ACS estimate\")\n```\n:::\n\n\n## Graduated symbol maps\n\nThere are many other effective ways to map statistical data besides choropleth maps. One such example is the graduated symbol map, which represents statistical variation by differently-sized symbols. In this exercise, you'll learn how to use the st_centroid() tool in the sf package to create points at the center of each state to be used as inputs to a graduated symbol map in ggplot2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\n\n# Generate point centers\ncenters <- st_centroid(state_value)\n\n# Set size parameter and the size range\nggplot() + \n  geom_sf(data = state_value, fill = \"white\") + \n  geom_sf(data = centers, aes(size = estimate), shape = 21, \n          fill = \"lightblue\", alpha = 0.7, show.legend = \"point\") + \n  scale_size_continuous(range = c(1, 20))\n```\n\n::: {.cell-output-display}\n![](us_census_files/figure-html/unnamed-chunk-37-1.png){width=4200}\n:::\n:::\n\n\n## Faceted maps with ggplot2\n\nOne of the most powerful features of ggplot2 is its support for faceted plotting, in which multiple plots are generated for unique values of a column in the data. Faceted maps can be produced with geom_sf() in this way as well if tidycensus data are in tidy format. In this exercise, you'll produce faceted maps that show the racial and ethnic geography of Washington, DC from the 2010 decennial Census.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check the first few rows of the loaded dataset dc_race\nhead(dc_race)\n\n# Remove the gridlines and generate faceted maps\nggplot(dc_race, aes(fill = percent, color = percent)) + \n  geom_sf() + \n  coord_sf(datum = NA) + \n  facet_wrap(~variable)\n```\n:::\n\n\n## Interactive visualization with mapview\n\nThe mapview R package allows R users to interactively map spatial datasets in one line of R code. This makes it an essential tool for exploratory spatial data analysis in R. In this exercise, you'll learn how to quickly map tidycensus data interactively using mapview and your Orange County, California median housing values dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add a legend to your map\nm <- mapview(orange_value, \n         zcol = \"estimate\", \n         legend = TRUE)\nm@map\n```\n:::\n\n\n## Generating random dots with sf\n\nDot-density maps are created by randomly placing dots within areas where each dot is proportional to a certain number of observations. In this exercise, you'll learn how to create dots in this way with the sf package using the st_sample() function. You will generate dots that are proportional to about 100 people in the decennial Census, and then you will group the dots to speed up plotting with ggplot2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate dots, create a group column, and group by group column\ndc_dots <- map(c(\"White\", \"Black\", \"Hispanic\", \"Asian\"), function(group) {\n  dc_race %>%\n    filter(variable == group) %>%\n    st_sample(., size = .$value / 100) %>%\n    st_sf() %>%\n    group_by(group = group) \n}) %>%\n  reduce(rbind) %>%\n  group_by(group) %>%\n  summarize()\n```\n:::\n\n\n## Obtaining data for cartography with tigris\n\nBefore making your dot-density map of Washington, DC with ggplot2, it will be useful to acquire some ancillary cartographic data with the tigris package that will help map viewers understand what you've visualized. These datasets will include major roads in DC; area water features; and the boundary of the District of Columbia, which you'll use as a background in your map.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filter the DC roads object for major roads only\ndc_roads <- roads(\"DC\", \"District of Columbia\") %>%\n  filter(RTTYP %in% c(\"I\", \"S\", \"U\"))\n\n# Get an area water dataset for DC\ndc_water <- area_water(\"DC\", \"District of Columbia\")\n\n# Get the boundary of DC\ndc_boundary <- counties(\"DC\", cb = TRUE)\n```\n:::\n\n\n## Making a dot-density map with ggplot2\n\nIn your final exercise of this course, you are going to put together the datasets you've acquired and generated into a dot-density map with ggplot2. You'll plot your generated dots and ancillary datasets with geom_sf(), and add some informative map elements to create a cartographic product.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot your datasets and give your map an informative caption\nggplot() + \n  geom_sf(data = dc_boundary, color = NA, fill = \"white\") + \n  geom_sf(data = dc_dots, aes(color = group, fill = group), size = 0.1) + \n  geom_sf(data = dc_roads, color = \"lightblue\", fill = \"lightblue\") + \n  geom_sf(data = dc_water, color = \"grey\") + \n  coord_sf(crs = 26918, datum = NA) + \n  scale_color_brewer(palette = \"Set1\", guide = FALSE) +\n  scale_fill_brewer(palette = \"Set1\") +\n  labs(title = \"The racial geography of Washington, DC\", \n       subtitle = \"2010 decennial U.S. Census\", \n       fill = \"\", \n       caption = \"1 dot = approximately 100 people.\\nData acquired with the R tidycensus and tigris packages.\")\n```\n:::\n",
    "supporting": [
      "us_census_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}