{
  "hash": "a9108324cb7b9a721d6ebc62c716f4a0",
  "result": {
    "markdown": "---\ntitle: \"Sampling in R\"\noutput: github_document\n---\n\n\n\n\n## Reasons for sampling\n\nSampling is an important technique in your statistical arsenal. It isn't always appropriate though---you need to know when to use it and when to work with the whole dataset.\n\n-   Which of the following is not a good scenario to use sampling?\n-   when data set is small\n\n## Simple sampling with dplyr\n\nThroughout this chapter you'll be exploring song data from Spotify. Each row of the dataset represents a song, and there are 41656 rows. Columns include the name of the song, the artists who performed it, the release year, and attributes of the song like its duration, tempo, and danceability. We'll start by looking at the durations.\n\nYour first task is to sample the song dataset and compare a calculation on the whole population and on a sample.\n\nspotify_population is available and dplyr is loaded.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(fst)\nlibrary(knitr)\nspotify_population <- read_fst(\"data/spotify_2000_2020.fst\")\n# View the whole population dataset\n\n# Sample 1000 rows from spotify_population\nspotify_sample <- slice_sample(spotify_population, n = 10)\n\n\n# See the result\nkable(spotify_sample)\n```\n\n::: {.cell-output-display}\n| acousticness|artists                                                              | danceability| duration_ms| duration_minutes| energy| explicit|id                     | instrumentalness| key| liveness| loudness| mode|name                               | popularity|release_date | speechiness|   tempo| valence| year|\n|------------:|:--------------------------------------------------------------------|------------:|-----------:|----------------:|------:|--------:|:----------------------|----------------:|---:|--------:|--------:|----:|:----------------------------------|----------:|:------------|-----------:|-------:|-------:|----:|\n|     7.14e-01|['alt-J']                                                            |        0.682|      217320|        3.6220000|  0.581|        0|3xqxETvPg43KWP0HOGiOmu |         3.24e-01|   7|   0.0802|  -10.339|    1|Something Good                     |         55|2012-09-18   |      0.0295| 108.981|   0.539| 2012|\n|     5.18e-05|['Two Door Cinema Club']                                             |        0.544|      222880|        3.7146667|  0.865|        0|3KL3eFVpAVW36M9YrK2Zrk |         2.90e-04|   2|   0.1160|   -4.644|    1|Changing of the Seasons            |         55|2013-01-01   |      0.1370| 130.014|   0.593| 2013|\n|     4.99e-02|['The Wreckers']                                                     |        0.513|      211533|        3.5255500|  0.720|        0|6kYMu0guz9F1BMoTh7w9iD |         0.00e+00|   6|   0.0535|   -4.488|    1|Leave the Pieces                   |         44|2006-03-28   |      0.0273| 164.099|   0.500| 2006|\n|     1.87e-02|['Brian Tuey', 'James McCawley', 'Kevin Sherwood', 'Treyarch Sound'] |        0.518|      239240|        3.9873333|  0.801|        0|128zElW4z27JtpfRKPkJwF |         0.00e+00|  10|   0.0988|   -6.091|    0|Lullaby Of A Deadman               |         54|2011-01-25   |      0.0445| 160.100|   0.491| 2011|\n|     1.85e-01|['RÃ¶yksopp']                                                         |        0.704|      317092|        5.2848667|  0.927|        0|238vPTkV2cKupWDnAietb6 |         1.08e-01|   9|   0.3250|   -7.157|    1|What Else Is There ?               |         44|2005-06-22   |      0.0436| 114.994|   0.342| 2005|\n|     1.68e-02|['blink-182']                                                        |        0.408|       42400|        0.7066667|  0.988|        1|5lE1g5Qsi1stIjYh8O5FC1 |         0.00e+00|  11|   0.5060|   -2.028|    1|Happy Holidays, You Bastard        |         50|2001         |      0.0961| 172.529|   0.963| 2001|\n|     6.49e-01|['Jerry Douglas', 'Mumford & Sons', 'Paul Simon']                    |        0.467|      245400|        4.0900000|  0.370|        0|04Dqz6T7vL4APHblHSdR4q |         4.42e-05|   0|   0.0949|  -11.231|    1|The Boxer                          |         55|2012-09-25   |      0.0320|  98.646|   0.272| 2012|\n|     8.90e-01|['The Milk Carton Kids']                                             |        0.554|      330772|        5.5128667|  0.235|        0|0WkJWnMCumm1fnFscdY7Rw |         3.28e-03|  10|   0.1140|  -14.609|    1|Michigan                           |         64|2011-07-19   |      0.0342| 121.836|   0.232| 2011|\n|     9.62e-01|['John Tesh']                                                        |        0.282|      181973|        3.0328833|  0.195|        0|1YvfddO5B4IAbE83XzkQeg |         8.82e-01|   9|   0.1030|  -11.952|    1|Brian's Song (From \"Brian's Song\") |         39|2000-04-18   |      0.0281|  72.498|   0.137| 2000|\n|     5.79e-02|['Black Rob']                                                        |        0.736|      238840|        3.9806667|  0.705|        1|71u5SjnkSQgzIt1UzHchbi |         0.00e+00|   7|   0.3210|   -6.231|    1|Whoa!                              |         54|2000         |      0.2400|  86.404|   0.557| 2000|\n:::\n:::\n\n\n## Simple sampling with dplyr\n\nThroughout this chapter you'll be exploring song data from Spotify. Each row of the dataset represents a song, and there are 41656 rows. Columns include the name of the song, the artists who performed it, the release year, and attributes of the song like its duration, tempo, and danceability. We'll start by looking at the durations.\n\nYour first task is to sample the song dataset and compare a calculation on the whole population and on a sample.\n\nspotify_population is available and dplyr is loaded.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate the mean duration in mins from spotify_population\nmean_dur_pop <- summarize(spotify_population, mean(duration_minutes))\n\n\n# Calculate the mean duration in mins from spotify_sample\nmean_dur_samp <- summarize(spotify_sample, mean(duration_minutes))\n\n\n# See the results\nmean_dur_pop\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  mean(duration_minutes)\n1               3.852152\n```\n:::\n\n```{.r .cell-code}\nmean_dur_samp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  mean(duration_minutes)\n1                3.74575\n```\n:::\n:::\n\n\n## Simple sampling with base-R\n\nWhile dplyr provides great tools for sampling data frames, if you want to work with vectors you can use base-R.\n\nLet's turn it up to eleven and look at the loudness property of each song.\n\nspotify_population is available.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# From previous step\nloudness_pop <- spotify_population$loudness\nloudness_samp <- sample(loudness_pop, size = 100)\n\n# Calculate the standard deviation of loudness_pop\nsd_loudness_pop <- sd(loudness_pop)\n\n# Calculate the standard deviation of loudness_samp\nsd_loudness_samp <- sd(loudness_samp)\n\n# See the results\nsd_loudness_pop\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.524076\n```\n:::\n\n```{.r .cell-code}\nsd_loudness_samp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.686226\n```\n:::\n:::\n\n\n## Are findings from the sample generalizable?\n\nYou just saw how convenience sampling---collecting data via the easiest method can result in samples that aren't representative of the whole population. Equivalently, this means findings from the sample are not generalizable to the whole population. Visualizing the distributions of the population and the sample can help determine whether or not the sample is representative of the population.\n\nThe Spotify dataset contains a column named acousticness, which is a confidence measure from zero to one of whether the track is acoustic, that is, it was made with instruments that aren't plugged in. Here, you'll look at acousticness in the total population of songs, and in a sample of those songs.\n\nspotify_population and spotify_mysterious_sample are available; dplyr and ggplot2 are loaded.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(spotify_population, aes(acousticness))+\n    geom_histogram(binwidth = 0.01)\n```\n\n::: {.cell-output-display}\n![](sampling_R_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(spotify_population, aes(duration_minutes))+\n    geom_histogram(binwidth = 0.5)\n```\n\n::: {.cell-output-display}\n![](sampling_R_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n## Generating random numbers\n\nYou've seen sample() and it's dplyr cousin, slice_sample() for generating pseudo-random numbers from a set of values. A related task is to generate random numbers that follow a statistical distribution, like the uniform distribution or the normal distribution.\n\nEach random number generation function has a name beginning with \"r\". It's first argument is the number of numbers to generate, but other arguments are distribution-specific. Free hint: Try args(runif) and args(rnorm) to see what arguments you need to pass to those functions.\n\nn_numbers is available and set to 5000; ggplot2 is loaded.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_numbers <- 5000\n# Generate random numbers from ...\nrandoms <- data.frame(\n  # a uniform distribution from -3 to 3\n  uniform =runif(n_numbers, -3, 3),\n  # a normal distribution with mean 5 and sd 2\n  normal = rnorm(n_numbers, mean = 5, sd = 2)\n)\n\n\n# Plot a histogram of uniform values, binwidth 0.25\nggplot(randoms, aes(uniform)) +\n    geom_histogram(binwidth = 0.25)\n```\n\n::: {.cell-output-display}\n![](sampling_R_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Plot a histogram of normal values, binwidth 0.5\nggplot(randoms, aes(normal)) +\n    geom_histogram(binwidth = 0.5)\n```\n\n::: {.cell-output-display}\n![](sampling_R_files/figure-html/unnamed-chunk-6-2.png){width=672}\n:::\n:::\n\n\n## Understanding random seeds\n\nWhile random numbers are important for many analyses, they create a problem: the results you get can vary slightly. This can cause awkward conversations with your boss when your script for calculating the sales forecast gives different answers each time.\n\nSetting the seed to R's random number generator helps avoid such problems by making the random number generation reproducible. - The values of x are different to those of y.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nx <- rnorm(5)\ny <- rnorm(5)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.56047565 -0.23017749  1.55870831  0.07050839  0.12928774\n```\n:::\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1.7150650  0.4609162 -1.2650612 -0.6868529 -0.4456620\n```\n:::\n:::\n\n\n-   x and y have identical values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nx <- rnorm(5)\nset.seed(123)\ny <- rnorm(5)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.56047565 -0.23017749  1.55870831  0.07050839  0.12928774\n```\n:::\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.56047565 -0.23017749  1.55870831  0.07050839  0.12928774\n```\n:::\n:::\n\n\n-   x and y have identical values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nx <- c(rnorm(5), rnorm(5))\nset.seed(123)\ny <- rnorm(10)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] -0.56047565 -0.23017749  1.55870831  0.07050839  0.12928774  1.71506499\n [7]  0.46091621 -1.26506123 -0.68685285 -0.44566197\n```\n:::\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] -0.56047565 -0.23017749  1.55870831  0.07050839  0.12928774  1.71506499\n [7]  0.46091621 -1.26506123 -0.68685285 -0.44566197\n```\n:::\n:::\n",
    "supporting": [
      "sampling_R_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}