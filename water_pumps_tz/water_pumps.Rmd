---
title: "Tanzanian Water Pumps"
author: "Mburu"
date: "4/21/2020"
output:
  html_document:
    theme: united
    highlight: pygments
    df_print: paged
    toc: yes
  prettydoc::html_pretty:
    highlight: github
    theme: leonids
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```



```{r}

library(tidyverse)
library(data.table)
library(knitr)
library(broom)
library(caret)
library(kableExtra)
library(ggthemes)
library(DT)
```

## 

```{r cars}

train_y <- fread("0bf8bc6e-30d0-4c50-956a-603fc693d966.csv")
train_x <-  fread("4910797b-ee55-40a7-8668-10efd5c1b960.csv")

test <- fread("702ddfc5-68cd-4d1d-a0de-f5f566f76d91.csv")

```

## 

```{r}
train_data <- merge(train_y, train_x, by = "id")
train_data[, set := "train"]

test[, set := "test"]

pump_data <- rbindlist(list(train_data, test), fill = T)

```



```{r}

train_data[, .N, by = status_group] %>%
    .[, Perc :=  round(N/sum(N) * 100, 2)] %>%
    datatable()

```


```{r}
pump_data[amount_tsh != 0, .(Mean = mean(amount_tsh),
               Median = median(amount_tsh),
               Min = min(amount_tsh),
               Max = max(amount_tsh),
               First_qurtile = quantile(amount_tsh, .25),
               Third_qurtile = quantile(amount_tsh, .75)),
           by = status_group] %>%
  datatable()
```


```{r}
col_class <- sapply(train_data, class)
char_cols <- names(col_class[col_class == "character"])

char_cols <- char_cols[char_cols != "date_recorded"]
char_cols
```

## A lazy way of collapsing columns, Please do it,
* It's best to go through all columns one by one to see how well lumping together will be beneficial

```{r}


factor_cols <- pump_data[, ..char_cols]
factor_cols[, (char_cols) := lapply(.SD, str_to_lower), .SDcols = char_cols]
factor_cols[, (char_cols) := lapply(.SD,  fct_lump_n, n = 10), .SDcols = char_cols]
#factor_cols[, (char_cols) := lapply(.SD,  fct_lump_n, n = 5), .SDcols = char_cols]
factor_cols[factor_cols == ""] = NA
factor_cols[, (char_cols) :=lapply(.SD, fct_explicit_na, na_level = "Other"), .SDcols = char_cols]
```


```{r}
chars_dat <- melt(pump_data[, ..char_cols], 
                  id.vars = c("set", "status_group"))

chars_dat[, .(freq = .N), by = .(variable, value)] %>%
  .[variable != "funder"] %>%
    datatable()
```


```{r}
pump_data[, go_funded := 
              ifelse(grepl("government of tanzania|ministry|district council",
                           tolower(funder)), "gov", "ngo")]

pump_data[set == "train", .N, by = .(go_funded,status_group)] %>%
    .[, perc := round(N/sum(N) * 100, 2), by = .(go_funded)] %>%
    
     ggplot(aes(go_funded, perc, fill = status_group)) +
     geom_bar(stat = "identity") +
     geom_text(aes(go_funded, perc, label = paste(perc, "%"),
                   vjust = .05, hjust = .5),
               size = 4, position = position_stack(vjust = 0.5))+
     theme_hc()+
    labs(title = "Percentage loans_")+
     scale_fill_economist(name = "")+
    theme(legend.position = "bottom")

```


```{r}
pump_data[set == "train", .N, by = .(water_quality,status_group)] %>%
    .[, perc := round(N/sum(N) * 100, 2), by = .(water_quality)] %>%
    
     ggplot(aes(water_quality, perc, fill = status_group)) +
     geom_bar(stat = "identity") +
     geom_text(aes(water_quality, perc, label = paste(perc, "%"),
                   vjust = .05, hjust = .5),
               size = 4, position = position_stack(vjust = 0.5))+
     theme_hc()+
    labs(title = "Percentage loans_")+
     scale_fill_economist(name = "")+
    theme(legend.position = "bottom")
```


```{r}
pump_data[, go_installer := 
              ifelse(grepl("gover|ministry|district",
                           tolower(installer)), "gov", "ngo")]

pump_data[set == "train", .N, by = .(go_installer,status_group)] %>%
    .[, perc := round(N/sum(N) * 100, 2), by = .(go_installer)] %>%
    
     ggplot(aes(go_installer, perc, fill = status_group)) +
     geom_bar(stat = "identity") +
     geom_text(aes(go_installer, perc, label = paste(perc, "%"),
                   vjust = .05, hjust = .5),
               size = 4, position = position_stack(vjust = 0.5))+
     theme_hc()+
    labs(title = "")+
     scale_fill_economist(name = "")+
    theme(legend.position = "bottom")
```

```{r}
pump_data[construction_year == 0, construction_year := NA]
summary(pump_data$construction_year)

pump_data[, construction_year2  := cut(construction_year, breaks = c(1959, 1988, 2000, 2008, 2013))]
pump_data[, construction_year2 := fct_explicit_na(construction_year2, na_level = "unknown")]
```

```{r}
pump_data[, waterpoint_type_group1 := fct_lump_n(waterpoint_type_group, n = 5)]


pump_data[set == "train", .N, by = .(waterpoint_type_group1,status_group)] %>%
    .[, perc := round(N/sum(N) * 100, 2), by = .(waterpoint_type_group1)] %>%
    
     ggplot(aes(waterpoint_type_group1, perc, fill = status_group)) +
     geom_bar(stat = "identity") +
     geom_text(aes(waterpoint_type_group1, perc, label = paste(perc, "%"),
                   vjust = .05, hjust = .5),
               size = 4, position = position_stack(vjust = 0.5))+
     theme_hc()+
    labs(title = "")+
     scale_fill_economist(name = "")+
    theme(legend.position = "bottom")


```


```{r}
pump_data[, management_group1:= fct_lump_n(management_group, n = 3)]

pump_data[,.N, by = management_group1] %>% kable()
```


```{r}

# train_set <- pump_data[set == "train",
#                        .(status_group, go_funded, water_quality,
#                          quantity,  construction_year2,
#                          management_group, go_installer,
#                          waterpoint_type_group1, longitude, latitude, basin,
#                          management_group1)]

#is there biase in recording
del_cols <- c( "recorded_by")
data_clean <- cbind(pump_data[, .(construction_year2, latitude, longitude)], factor_cols)

train_set <- data_clean[set == "train"]
train_set[, set := NULL]
char_cols2 <- char_cols[!char_cols %in% c("status_group" )]
train_set_dmmy <- dummies::dummy.data.frame(train_set, names = char_cols2) %>% setDT()
train_set_dmmy[, status_group := factor(status_group,
                                   levels = c("functional", "functional needs repair", "non functional"),
                                   labels  = c("functional", "functional_needs_repair", "non_functional"))]
```


```{r}
set.seed(100)
#train_set <- train_set[status_group %in% c("functional", "functional_needs_repair") ]
train_ind <- sample(1:nrow(train_set_dmmy), round(0.7 * nrow(train_set)))
train_set_dmmy[, status_group := factor(status_group)]

train_set1 <- train_set_dmmy[train_ind,]

xgb_ctrl <- trainControl(method = "cv",
                        number = 5,
                        summaryFunction = multiClassSummary,
                        classProbs = TRUE,
                        allowParallel=T,
                        #index = cv_fold,
                        verboseIter = TRUE,
                        savePredictions = TRUE,
                        search = "grid")
# 
# xgb_grid <- expand.grid(nrounds = c(10, 50, 100),
#                         eta = seq(0.06, .2, length.out = 3),
#                         max_depth = c(80, 150, 200),
#                         gamma = c(0,.01, 0.1),
#                         colsample_bytree = c(0.6, 0.7,0.8),
#                         min_child_weight = c(0.6, 0.7,0.8),
#                         subsample =  c(0.6, 0.7,0.8)
# 
#     )




xgb_grid <-  expand.grid(nrounds = c(50,100),
                        eta = 0.06,
                        max_depth = 50,
                        gamma = c(0.001, 8),
                        colsample_bytree = 0.8,
                        min_child_weight =0.6,
                        subsample =  .8)


xgb_model <-train(status_group~.,
                 data=train_set1,
                 method="xgbTree",
                 trControl= xgb_ctrl,
                 tuneGrid=xgb_grid,
                 verbose=T,
                 metric="ROC",
                 nthread =3
                     
    )

xgb_model 
```






```{r}
test_own <- train_set_dmmy[-train_ind]
pred <- predict(xgb_model, type="raw", newdata = test_own)
```





```{r}
confusionMatrix(pred,
                test_own$status_group)
```



```{r}
SubmissionFormat <- fread("SubmissionFormat.csv")
```




```{r}
# Alternatively, you can put in dense matrix, i.e. basic R-matrix
# library(lightgbm)
# 
# train_x <- as.matrix(train_set1[, !status_group])
# train_y <- train_set1$status_group
# 
# 
# params = list('task'= 'train',
#     'boosting_type'= 'gbdt',
#     'objective'= 'multiclass',
#     'num_class'=3,
#     'metric'= 'multi_logloss',
#     'learning_rate'= 0.002296,
#     'max_depth'= 7,
#     'num_leaves'= 17,
#     'feature_fraction'= 0.4,
#     'bagging_fraction'= 0.6,
#     'bagging_freq'= 17)
# 
# train_lgb = lgb.Dataset(data = train_x , label = train_y, params = params)
# 
# print("Training lightgbm with Matrix")
# 
# bst <- lightgbm(
#     data = train_lgb
#     , num_leaves = 4L
#     , learning_rate = 1.0
#     , nrounds = 2L
#     , objective = "multiclass"
# )
```

